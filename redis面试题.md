# Redis

#### 基础数据结构和各自的使用场景，高级用法
- string: 常用的key-value对。
- list: 使用场景：消息队列。
- hash: 
- set:
- zset:
#### 缓存雪崩，缓存穿透，缓存击穿
- 缓存雪崩：如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会
  导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。  
- 缓存穿透：缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻
  击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。
- 缓存击穿：缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没
  读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。  
#### 布隆过滤器
    针对缓存穿透的解决方案，如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定
    的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，
    如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。
#### 分布式锁
    
#### 怎么查询某个前缀开头的key？keys -> 若数据量很大？

#### Redis做异步队列缺点，lpop -> blpop, blpop怎么实现

#### Redis为什么那么快
    redis是纯内存操作：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。
    非阻塞I/O：Redis采用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。
    单线程避免了线程切换和竞态产生的消耗。
#### Redis生产一次消费多次
    使用 pub/sub 发布订阅模式，可以实现 1:N 的消息队列，即一次生产，多端消费
    但不在线的消费者会产生消息丢失的情况
#### Redis pub/sub有什么缺点
- 消费者下线，消息丢失。
- redis宕机，相当于全部消费者下线，消息全部丢失。
    
#### Redis如何实现延时队列
    zset实现，timestamp实现

#### Redis持久化策略

#### Redis同步原理

#### sentinal & cluster的区别
    redis主从复制，并且引入哨兵机制监控与自动处理故障。

#### 内存淘汰机制

#### Redis过期策略

#### 在集群模式下，Redis 的 Key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 Hash 算法吗？

#### 如何保证有限内存中Redis中的数据都是热点数据