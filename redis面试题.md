# Redis

#### 基础数据结构和各自的使用场景，高级用法
- string: 常用的key-value对。
- list: 使用场景：消息队列。
- hash: 
- set:
- zset:
#### 缓存雪崩，缓存穿透，缓存击穿
- 缓存雪崩：如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会
  导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。  
- 缓存穿透：缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻
  击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。
- 缓存击穿：缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没
  读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。  
#### 布隆过滤器
    针对缓存穿透的解决方案，如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定
    的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，
    如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。
#### 分布式锁
##### 基于redis的分布式锁
[redis分布式锁](http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/)  
    一个严谨的流程（假设过期时间是充足的）如下：
    1. 加锁：SET $lock_key $unique_id EX $expire_time NX, 客户端加锁时，设置uuid便于识别是否是自己的锁。
    2. 操作共享资源
    3. 释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁
    上述解决了锁过期时间内，一个客户端释放了另一个客户端持有锁的问题。  
##### 锁过期时间不好评估的解决方案
    加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进
    行「续期」，重新设置过期时间。例如java的Redisson。
##### 主从复制+哨兵的redis集群场景分析
    分布式锁丢失场景：
    1. 客户端 1 在主库上执行 SET 命令，加锁成功
    2. 此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）
    3. 从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！
    redlock呼应而出。不过redlock仍旧存在很多问题。虽然redis集群会在主从切换时发生锁丢失的可能。仍旧侧重该方案。
#### 怎么查询某个前缀开头的key？keys -> 若数据量很大？
    keys pattern一次性返回所有数据。数据量过大会导致服务卡顿。SCAN cursor [MATCH pttern] [Count count] //SCAN是无阻塞模式的提取指令列
表，每次只会返回少量元素。
#### Redis做异步队列缺点，lpop -> blpop, blpop怎么实现

#### Redis为什么那么快
    redis是纯内存操作：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。
    非阻塞I/O：Redis采用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。
    单线程避免了线程切换和竞态产生的消耗。
#### Redis生产一次消费多次
    使用 pub/sub 发布订阅模式，可以实现 1:N 的消息队列，即一次生产，多端消费
    但不在线的消费者会产生消息丢失的情况
#### Redis pub/sub有什么缺点
    1. 消费者下线，消息丢失。
    2. redis宕机，相当于全部消费者下线，消息全部丢失。
    
#### Redis如何实现延时队列
    zset实现，timestamp实现

#### Redis持久化策略
##### AOF 
    定义：即 append only file，当 redis 采用这这种数据持久化策略的时候，每当 redis 服务器收到一条更新命令时，操作结束之后会将这条命令添加
    到 aof 内存缓冲区，特定的时间下刷新缓冲区到磁盘文件中，也就是我们的 aof 文件。
    优点：
        1. 相同的数据量下，rdb 文件要小于 aof 文件，且恢复速度要快于 aof
        2. rdb 文件中是整个数据的完整备份快照，数据存储紧凑即便不同版本的 redis，也能顺利恢复
        3. 整个 rdb 持久化，只需要 fork 一个子进程进行持久化即可，父进程依然可以提供服务，效率最大化
    缺点：
        1. 容易丢失数据，即便配置了事件时间触发备份，也至少丢失一秒数据
        2. 如果数据量太大，fork 子进程的时候会阻塞毫秒级别时间
    
##### RDB
    定义：RDB 基于内存快照，有两种方式 save 和 bgsave，前者会阻塞 redis 服务，后者是异步 fork 子进程不影响主进程提供服务。大部分情况，我们会
    通过配置时间间隔触发 RDB 文件写入。RDB 文件中保存的是 redis 内存中所有的数据一份快照。
    优点：
        1. 相较于 RDB，AOF 数据可靠性更强，最多丢失一秒数据
        2. 数据库容错率变好，一些误操作可以通过直接改 aof 文件进行回退
    缺点：
        1. AOF 文件通常较大且恢复效率比不上 RDB，不适合做数据冷备份
##### 结论
    总的来说，AOF 策略会使数据稳定性更高，具有更完整的数据备份，RDB 恢复效率高适合做灾难恢复，建议生产环境上两者都开启。
#### Redis同步原理

#### sentinal & cluster的区别
    redis主从复制，并且引入哨兵机制监控与自动处理故障。

<a id="memoryeLimination"></a>
#### 内存淘汰机制
    根基二八原则，20%的数据可以拦截80%的请求。所以一般缓存内存的大小一般小于数据总量。这就导致缓存会被写满。所以需要设置内存淘汰策略。
##### LRU淘汰策略
- 记录每个 key 最近一次被访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）
- 在第一次淘汰数据时，会先随机选择 N 个数据作为一个候选集合，然后淘汰 lru 值最小的。（N 可以通过 config set maxmemory-samples 100 命令来配置）
- 后续再淘汰数据时，会挑选数据进入候选集合，进入集合的条件是：它的 lru 小于候选集合中最小的 lru。
- 如果候选集合中数据个数达到了 maxmemory-samples，Redis 就会将 lru 值小的数据淘汰出去。
##### LFU淘汰策略
    前面说到，LRU 使用了 RedisObject 中的 lru 字段记录时间戳，lru 是 24bit 的，LFU 将 lru 拆分为两部分：
    ldt 值：lru 字段的前 16bit，表示数据的访问时间戳
    counter 值：lru 字段的后 8bit，表示数据的访问次数
    使用 LFU 策略淘汰缓存时，会把访问次数最低的数据淘汰，如果访问次数相同，再根据访问的时间，将访问时间戳最小的淘汰。
<a id="expirationstrategy"></a>
#### Redis过期策略
- 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源
  去处理过期的数据，从而影响缓存的响应时间和吞吐量。

- 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过
  期key没有再次被访问，从而不会被清除，占用大量内存。

- 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定
  时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期时间
  数据，其中key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)
#### 在集群模式下，Redis 的 Key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 Hash 算法吗？
[redis一致性算法](https://blog.csdn.net/qq_21125183/article/details/90019034?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.highlightwordscore&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.highlightwordscore)
- 传统hash: redis集群中某个master宕机，会造成缓冲雪崩。
- 一致性hash: redis集群中master节点全部hash到一个圆环上（也就是挂到圆环上），请求到来时，key同样hash到圆环上。该次请求会打到keyhash点按顺时
  针找到的第一个master节点。服务器节点的增减只需重新构建一部分缓存，具有良好的容错性和扩展性。但是服务器较少时会有数据倾斜严重的问题。
- 一致性hash+虚拟节点：之前服务器节点挂载到节点上是通过hash随机决定的，这可能导致数据倾斜问题。可以实现均匀挂载虚拟节点，然后虚拟节点定向到实际服
  务节点，这就解决了数据可能倾斜的问题。
- hash slot: 一个节点持有一个范围的slot, 即是服务器节点增减也只是部分缓存需要重新写入。
#### 如何保证有限内存中Redis中的数据都是热点数据
[内存淘汰策略](#memoryeLimination) + [过期策略](#expirationstrategy)